<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>A Novice Programmer</description>
    <link>https://qoiuy.github.io/</link>
    <atom:link href="https://qoiuy.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 19 Aug 2016 14:33:43 +0800</pubDate>
    <lastBuildDate>Fri, 19 Aug 2016 14:33:43 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>第一篇博客</title>
        <description>&lt;p&gt;花了１天功夫终于将博客搭完了．．累&lt;/p&gt;

&lt;p&gt;最近在找工作．找工作．找工作．&lt;/p&gt;

&lt;p&gt;将自己学习到的一些知识总结一下，放在这里，嘿嘿&lt;/p&gt;

&lt;p&gt;此文章纪念博客搭建完成&lt;/p&gt;

</description>
        <pubDate>Wed, 17 Aug 2016 00:00:00 +0800</pubDate>
        <link>https://qoiuy.github.io/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</link>
        <guid isPermaLink="true">https://qoiuy.github.io/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</guid>
        
        
      </item>
    
      <item>
        <title>Redis</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;REmote DIctionary Server is an open source (BSD licensed), in-memory data structure store, used as database, cache and message broker.
&lt;a href=&quot;http://redis.io/&quot;&gt;Redis官网&lt;/a&gt;
&lt;a href=&quot;https://github.com/antirez/redis&quot;&gt;Redis源码&lt;/a&gt;
&lt;a href=&quot;http://item.jd.com/1552950364.html&quot;&gt;推荐书籍－Redis入门指南&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;redis&quot;&gt;&lt;a href=&quot;&quot;&gt;Redis特性&lt;/a&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(1)存储结构：字典(映射)结构存储数据，到目前为止Redis支持的键值数据类型如下:
    ● 字符串类型(String)
    ● 散列类型(Hash)
    ● 列表类型(List)
    ● 集合类型(Set)
    ● 有序集合类型(Zset)
(2)内存存储和持久化：Redis数据库中的所有数据都存储在内存中　Redis提供了对持久化的支持
(3)功能丰富:
    ● Redis可以为每个键设置生存时间(Time To Live,TTL)
    ● 在性能上Redis是单线程模型
    ● Redis还可以限定数据占用的最大内存空间
    ● Redis的列表类型键可以用来实现队列,并且支持阻塞式读取,
    ● Redis的贡献者之一Pieter Noordhuis提供了一个使用该模式开发的聊天室的例子
(4)简单稳定:
    ● Redis直观的存储结构使得通过程序与Redis交互十分简单
    ● Redis提供了一百多个命令,常用的只有十几个,并且每个命令都很容易记忆
    ● Redis提供了几十种不同编程语言的客户端库
    ● Redis使用C语言开发,代码量只有3万多行。
    ● Redis 是开源的
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;redisjava&quot;&gt;redis在项目中的实际应用(Java)&lt;/h3&gt;

&lt;h6 id=&quot;redisjava-1&quot;&gt;1.测试Redis(java)&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/images/java/redis01.png&quot; alt=&quot;使用Jedis&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;redisjava-spring&quot;&gt;2.测试Redis(java-spring)&lt;/h6&gt;
&lt;p&gt;配置Spring容器
&lt;img src=&quot;/images/java/redis02.png&quot; alt=&quot;&quot; /&gt;
编写测试类
&lt;img src=&quot;/images/java/redis03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;redisjava-spring-service&quot;&gt;3.使用Redis生成唯一编号(java-spring-service)&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/images/java/redis04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;redisjava-spring-&quot;&gt;4.使用Redis分布式缓存(java-spring 品牌管理)&lt;/h6&gt;
&lt;p&gt;确定存储在redis中的数据类型
&lt;img src=&quot;/images/java/redis05.png&quot; alt=&quot;&quot; /&gt;
使用redis保存数据(java-spring-service)
&lt;img src=&quot;/images/java/redis06.png&quot; alt=&quot;&quot; /&gt;
使用redis查询数据(java-spring-service)
&lt;img src=&quot;/images/java/redis07.png&quot; alt=&quot;&quot; /&gt;
使用redis查询数据(java-spring-controller)
&lt;img src=&quot;/images/java/redis08.png&quot; alt=&quot;&quot; /&gt;
使用redis查询数据(java-springMVC-jsp)
&lt;img src=&quot;/images/java/redis09.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;redis-1&quot;&gt;&lt;a href=&quot;&quot;&gt;安装Redis&lt;/a&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;略
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;redishttpswwwdoubancomnote145964921&quot;&gt;&lt;a href=&quot;https://www.douban.com/note/145964921/&quot;&gt;使用Redis之基础命令&lt;/a&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;KEYS pattern        获得符合规则的键名列表(pattern支持glob风格通配符格式)
EXISTS key          判断一个键是否存在(如果键存在则返回整数类型1,否则返回0)
                    和xargs 命令自己实现删除所有符合规则的键)
TYPE key 	          获得键值的数据类型
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;redisstring4&quot;&gt;&lt;a href=&quot;字符串类型是其他4种数据类型的基础,其他数据类型和字符串类型的差别从某种角度来说只是组织字符串的形式不同。例如,列表类型是以列表的形式组织字符串,而集合类型是以集合的形式组织字符串。&quot;&gt;使用Redis之String&lt;/a&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SET key value     赋值
GET key           取值
INCR key          递增数字
----------------------------------------------------------------------------
INCRBY key increment       增加指定的整数
DECR key                    递减数字
DECRBY key decrement         减少指定的整数
INCRBYFLOAT key increment     增加指定浮点数
APPEND key value               向尾部追加值
STRLEN key                      获取字符串长度
MGET key [key ...]               同时获取多个键值
MSET key value [key value ...]    同时设置多个键值
GETBIT key offset                  获得一个字符串类型键指定位置的二进制位的值
SETBIT key offset value             设置字符串类型键指定位置的二进制位的值
BITCOUNT key [start] [end]           获得字符串类型键中值是1的二进制位个数
BITOP operation destkey key [key ...] 对多个字符串类型键进行位运算 (AND、OR、
                                       XOR 和NOT)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;redisstringhttpmsgpackorg&quot;&gt;&lt;a href=&quot;http://msgpack.org&quot;&gt;实践Redis之String&lt;/a&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.文章访问量统计 post:文章ID:page.view
2.文章ID 对象类型(复数形式):count
3.存储文章数据 Json或者MessagePack
4.发布新文章时与Redis操作相关的伪代码:
    #首先获得新文章的ID
    $postID=INCR posts:count
    #将博客文章的诸多元素序列化成字符串
    $serializedPost=serialize($title,$content,$author,$time)
    #把序列化后的字符串存一个入字符串类型的键中
    $SET post:$postID:data,$serializedPost
    获取文章数据的伪代码如下(以访问ID 为42的文章为例):
    #从Redis 中读取文章数据
    $serializedPost=GET post:42:data
    #将文章数据反序列化成文章的各个元素
    $title,$content,$author,$time=unserialize($serializedPost)
    #获取并递增文章的访问数量
    $scount=INCR post:42:page.view
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;redishash232-1&quot;&gt;&lt;a href=&quot;一个散列类型键可以包含至多232-1个字段&quot;&gt;使用Redis之Hash&lt;/a&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HSET key field value                     给字段赋值(不区分插入和更新操作)
HGET key field                           获得字段的值
HMGET key field [field ...]              获得多个字段的值
HMSET key field value [field value ...]  同时设置多个字段的值
HGETALL key                              返回字段和字段值组成的列表
HEXISTS key field                        判断一个字段是否存在
HSETNX key field value                   当字段不存在时赋值
HSETNX key field value                   增加数字
HDEL key field [field ...]               删除字段
----------------------------------------------------------------------------
HKEYS key   只获取字段名
HVALS key    只获取字段值
HLEN key      获得字段数量
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;redishash&quot;&gt;&lt;a href=&quot;&quot;&gt;实践Redis之Hash&lt;/a&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.存储文章数据 　post:文章ID  字段　数据
2.存储文章缩略名　slug.to.id 文章缩略名 文章ID
3.发布文章 :
    $postID=INCR posts:count
    #判断用户输入的slug是否可用,如果可用则记录 (HSETNX比HEXISTS＋HSET 好)
    $isSlugAvailable=HSETNX slug.to.id, $slug, $postID
    if $isSlugAvailable is 0
    #slug已经用过了,需要提示用户更换slug,
    #这里为了演示方便直接退出。
    exit
    HMSET post: postID, title, title, content, content, slug, slug,...
4.当用户访问文章时
    #从网址中得到文章的缩略名,并查询slug.to.id键来获取文章ID
    $postID=HGET slug.to.id, $slug
    if not $postID
    print文章不存在
    exit
    $post=HGETALL post: $postID
	print文章标题: $post.title
5.修改ID为42的文章的缩略名为newSlug 变量的值(注意:如果要修改文章的缩略名一定不能忘了修改slug.to.id键对应的字段)
	#判断新的slug是否可用,如果可用则记录
    $$isSlugAvailable=HSETNX slug.to.id, $newSlug, 42
    if $isSlugAvailable is 0
    exit
    #获得旧的缩略名
    $oldSlug=HGET post:42, slug
    #设置新的缩略名
    HSET post:42, slug, $newSlug
    #删除旧的缩略名
    HDEL slug.to.id, $oldSlug
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;redislist232-1&quot;&gt;&lt;a href=&quot;一个列表类型键最多能容纳232-1个元素&quot;&gt;使用Redis之List&lt;/a&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LPUSH key value [value ...]  向列表左边增加元素
RPUSH key value [value ...]  向列表右边增加元素
LPOP key                     从列表左边弹出一个元素
RPOP key                     从列表右边弹出一个元素
LLEN key                     获取列表中元素的个数
LRANGE key start stop        获得列表片段(很有趣)
LREM key count value         删除列表中指定的值
----------------------------------------------------------------------------
LINDEX key index                  获得指定索引的元素值
LSET key index value               设置指定索引的元素值
LTRIM key start end                 只保留列表指定片段
POPLPUSH source destination          将元素从一个列表转到另一个列表R
LINSERT key BEFORE|AFTER pivot value  向列表中插入元素
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;redislist&quot;&gt;&lt;a href=&quot;&quot;&gt;实践Redis之List&lt;/a&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.存储文章ID列表 posts:list
2.当发布新文章时使用LPUSH命令把新文章的ID加入这个列表中
3.删除文章时把列表中的文章ID删除:LREM posts:list 1 要删除的文章ID
4.文章的分页显示
	$postsPerPage=10
    $start=( currentPage - 1) * $postsPerPage
    $end= $currentPage * $postsPerPage-1
    $postsID=LRANGE posts:list, $start, $end
    #获得了此页需要显示的文章ID列表,我们通过循环的方式来读取文章
    for each $id in $postsID
    $post=HGETALL post: $id
    print文章标题: $post.title
5.存储评论列表 使用列表类型键存储文章的评论
	#将评论序列化成字符串
    $serializedComment=serialize($author, $email, $time, $content)
    LPUSH post:42:comments, $serializedComment
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;redisset232-1&quot;&gt;&lt;a href=&quot;一个集合类型键可以存储至多232-1个字符串&quot;&gt;使用Redis之Set&lt;/a&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SADD key member [member ...]  增加元素
SREM key member [member ...]  删除元素
SMEMBERS key                  获得集合中的所有元素
SISMEMBER key member          判断元素是否在集合中
SDIFF key [key ...]           多个集合执行差集运算
SINTER key [key ...]          对多个集合执行交集运算
SUNION key [key ...]          对多个集合执行并集运算
----------------------------------------------------------------------------
SCARD key                          获得集合中元素个数
SRANDMEMBER key [count]             随机获得集合中的元素
SPOP key                             从集合中弹出一个元素
SDIFFSTORE destination key [key ...]  进行差集运算并将结果存储
SINTERSTORE destination key [key ...]  进行交集运算并将结果存储
SUNIONSTORE destination key [key ...]   进行并集运算并将结果存储
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;redisset&quot;&gt;&lt;a href=&quot;&quot;&gt;实践Redis之Set&lt;/a&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.存储文章标签 post:文章ID:tags
    #给ID为42的文章增加标签:
    SADD post:42:tags, 闲言碎语, 技术文章, Java
    # 删除标签:SREM post:42:tags, 闲言碎语
    #显示所有的标签:
    $tags=SMEMBERS post:42:tags
    print $tags
2.通过标签搜索文章　tag:标签名称:posts
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;rediszset&quot;&gt;&lt;a href=&quot;&quot;&gt;使用Redis之Zset&lt;/a&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ZADD key score member [score member ...] 增加元素
ZSCORE key member                        获得元素的分数
ZRANGE key start stop [WITHSCORES]       按照从小到大获得排名在某个范围的元素列表
ZREVRANGE key start stop [WITHSCORES]    按照从大到小获得排名在某个范围的元素列表
ZINCRBY key increment member             增加某个元素的分数
ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]		获得指定分数范围的元素
----------------------------------------------------------------------------
ZCARD key                   获得集合中元素的数量
ZCOUNT key min max           获得指定分数范围內的元素个数
ZREM key member [member ...]  删除一个或多个元素
ZREMRANGEBYRANK key start stop 按照排名范围删除元素
ZREMRANGEBYSCORE key min max    按照分数范围删除元素
ZRANK key member                 从小到大获得元素的排名
ZREVRANK key member               从大到小获得元素的排名
ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGREGATE SUM|MIN|MAX]              计算有序集合的交集
ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGREGATE SUM|MIN|MAX]                计算有序集合的并集
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;rediszset-1&quot;&gt;&lt;a href=&quot;&quot;&gt;实践Redis之Zset&lt;/a&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.实现按点击量排序 posts:page.view
    每次用户访问一篇文章时,ZINCRBY posts:page.view 1文章ID 更新访问量
2.需要按照点击量的顺序显示文章列表时
    $postsPerPage=10
    $start=( $currentPage-1) * $postsPerPage
    $end= $currentPage * $postsPerPage - 1
    $postsID=ZREVRANGE posts:page.view, $start, $end
    for each $id in $postsID
    $postData=HGETALL post: $id
    print文章标题: $postData.title
3.改进按时间排序(我不需要)
    用有序集合类型代替列表类型：元素仍然是文章的ID,而此时元素的分数则是文章发布的Unix时间。通过修改元素对应的分数就可以达到更改时间的目的
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;redis-2&quot;&gt;redis的应用场景&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;缓存（数据查询、短连接、新闻内容、商品内容等等）。（最多使用）
分布式集群架构中的session分离。
聊天室的在线好友列表。
任务队列。（秒杀、抢购、12306等等）
应用排行榜。
网站访问统计。
数据过期处理（可以精确到毫秒）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Wed, 17 Aug 2016 00:00:00 +0800</pubDate>
        <link>https://qoiuy.github.io/Redis/</link>
        <guid isPermaLink="true">https://qoiuy.github.io/Redis/</guid>
        
        
      </item>
    
      <item>
        <title>Mybatis</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;MyBatis SQL Mapper Framework for Java．
&lt;a href=&quot;http://www.mybatis.org/mybatis-3/zh/index.html&quot;&gt;Mybatis的中文官网&lt;/a&gt;
&lt;a href=&quot;https://github.com/mybatis/mybatis-3&quot;&gt;Mybatis项目代码库&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;mybatis&quot;&gt;Mybatis框架原理&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;		文件SqlMap.xml
			|
		全局配置文件ConfigMap.xml
			|
      应用程序--&amp;gt;SqlSessionFactoryBuilder.build()
                	|
                SqlSessionFactory.openSession()
                	|
      参数-----&amp;gt;SqlSession.selectOne() ---&amp;gt;输出
                	|
                    	DB
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;curd&quot;&gt;基本映射文件书写(CURD)&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#{}：代表占位符
${}:代表连接符

Create
　添加用户信息
    &amp;lt;insert id=&quot;insertUser&quot; parameterType=&quot;myBatis.inDoor.demo.pojo.User&quot;&amp;gt;
    	insert into user(username,birthday,sex,address) values(#{username},#{birthday},#{sex},#{address})
    &amp;lt;/insert&amp;gt;
Update
　更新用户信息
    &amp;lt;update id=&quot;updateUserById&quot; parameterType=&quot;myBatis.inDoor.demo.pojo.User&quot;&amp;gt;
    	update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address} where id = #{id}
    &amp;lt;/update&amp;gt;
Retrieve
　根据id查询信息
    &amp;lt;select id=&quot;queryUserById&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&amp;gt;
        select * from user where id = #{id}
    &amp;lt;/select&amp;gt;
　根据username查询用户信息
    &amp;lt;select id=&quot;queryUserByUserName&quot; parameterType=&quot;string&quot; resultType=&quot;user&quot;&amp;gt;
        select * from user where username like &#39;%${value}%&#39;
    &amp;lt;/select&amp;gt;
Delete
　删除用户信息
    &amp;lt;delete id=&quot;deleteUserById&quot; parameterType=&quot;int&quot;&amp;gt;
        delete from user where id = #{id}
    &amp;lt;/delete&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;三个对象的最佳使用范围&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SqlSessionFactoryBuilder
作用：用来加载mybatis的全局配置文件，产生会话工厂。
最佳使用范围：当做工具类来使用，而且作为局部变量

SqlSessionFactory
作用：产生会话
维护方式：通过单例来维护

SqlSession
作用：通过API调用指定的sql，并返回结果
最佳使用范围：作为一个局部变量来使用 ###	Mybatis Dao开发 ###	Mybatis Mapper代理Dao开发 ###	Mybatis 全局配置文件 ###	mybatis的输入映射和输出映射 ###	Mybatis的动态sql ###	Mybatis高级映射
一对一(1)
　&amp;lt;!-- 查询订单信息并关联查询用户信息   通过ResultType实现 --&amp;gt;
    &amp;lt;select id=&quot;queryOrdersAndUserByResultType&quot; resultType=&quot;ordersCustom&quot;&amp;gt;
        SELECT
          o.*,
          u.username,
          u.address
        FROM orders o,USER u
        WHERE u.id = o.user_id
    &amp;lt;/select&amp;gt;
一对一(2)
　&amp;lt;!-- 查询订单信息并关联查询用户信息   通过ResultType实现 --&amp;gt;
    &amp;lt;resultMap type=&quot;orders&quot; id=&quot;fieldIntoUser&quot;&amp;gt;
        &amp;lt;!-- 订单信息 --&amp;gt;
        &amp;lt;id column=&quot;id&quot; property=&quot;id&quot;/&amp;gt;
        &amp;lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&amp;gt;
        &amp;lt;result column=&quot;number&quot; property=&quot;number&quot;/&amp;gt;
        &amp;lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&amp;gt;
        &amp;lt;result column=&quot;note&quot; property=&quot;note&quot;/&amp;gt;
        &amp;lt;!-- 用户信息 --&amp;gt;
        &amp;lt;!-- 
            property:指定的就是orders中user属性
            javaType：返回的结果类型   一对一的关联关系
         --&amp;gt;
        &amp;lt;association property=&quot;user&quot; javaType=&quot;user&quot;&amp;gt;
            &amp;lt;result column=&quot;username&quot; property=&quot;username&quot;/&amp;gt;
            &amp;lt;result column=&quot;address&quot; property=&quot;address&quot;/&amp;gt;
        &amp;lt;/association&amp;gt;

    &amp;lt;/resultMap&amp;gt;
    &amp;lt;select id=&quot;queryOrdersAndUserByResultMap&quot; resultMap=&quot;fieldIntoUser&quot;&amp;gt;
        SELECT
          o.*,
          u.username,
          u.address
        FROM orders o,USER u
        WHERE u.id = o.user_id
    &amp;lt;/select&amp;gt;
一对多(1)
　&amp;lt;!-- 查询订单信息并关联明细信息   通过ResultMap实现 --&amp;gt;
    &amp;lt;resultMap type=&quot;orders&quot; id=&quot;fieldIntoDetail&quot; extends=&quot;fieldIntoUser&quot;&amp;gt;
        &amp;lt;!-- 订单信息 --&amp;gt;
        &amp;lt;!-- 用户信息 --&amp;gt;
        &amp;lt;!-- 订单明细 --&amp;gt;
        &amp;lt;collection property=&quot;orderdetails&quot; ofType=&quot;orderdetail&quot;&amp;gt;
            &amp;lt;id column=&quot;orderdetail_id&quot; property=&quot;id&quot;/&amp;gt;
            &amp;lt;result column=&quot;items_id&quot; property=&quot;itemsId&quot;/&amp;gt;
            &amp;lt;result column=&quot;items_num&quot; property=&quot;itemsNum&quot;/&amp;gt;
        &amp;lt;/collection&amp;gt;
    &amp;lt;/resultMap&amp;gt;
    &amp;lt;select id=&quot;queryOrdersAndDetailByResultMap&quot; resultMap=&quot;fieldIntoDetail&quot;&amp;gt;
        SELECT
          o.*,
          u.username,
          u.address,
          d.id orderdetail_id,
          d.items_id,
          d.items_num
        FROM orders o,USER u,orderdetail d
        WHERE u.id = o.user_id AND o.id = d.orders_id
    &amp;lt;/select&amp;gt;
多对多
   	　&amp;lt;!-- 查询用户信息并关联查询商品信息 --&amp;gt;
    &amp;lt;resultMap type=&quot;user&quot; id=&quot;allIntoUser&quot;&amp;gt;
	&amp;lt;!-- 用户信息 --&amp;gt;
	&amp;lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&amp;gt;
	&amp;lt;result column=&quot;username&quot; property=&quot;username&quot;/&amp;gt;
	&amp;lt;result column=&quot;address&quot; property=&quot;address&quot;/&amp;gt;
	&amp;lt;!-- 订单信息 --&amp;gt;
	&amp;lt;collection property=&quot;orderList&quot; ofType=&quot;orders&quot;&amp;gt;
		&amp;lt;id column=&quot;id&quot; property=&quot;id&quot;/&amp;gt;
		&amp;lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&amp;gt;
		&amp;lt;result column=&quot;number&quot; property=&quot;number&quot;/&amp;gt;
		&amp;lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&amp;gt;
		&amp;lt;result column=&quot;note&quot; property=&quot;note&quot;/&amp;gt;

	&amp;lt;!-- 明细信息 --&amp;gt;
		&amp;lt;collection property=&quot;orderdetails&quot; ofType=&quot;orderdetail&quot;&amp;gt;
			&amp;lt;id column=&quot;orderdetail_id&quot; property=&quot;id&quot;/&amp;gt;
			&amp;lt;result column=&quot;items_id&quot; property=&quot;itemsId&quot;/&amp;gt;
			&amp;lt;result column=&quot;items_num&quot; property=&quot;itemsNum&quot;/&amp;gt;

	&amp;lt;!-- 商品信息 --&amp;gt;
			&amp;lt;association property=&quot;items&quot; javaType=&quot;items&quot;&amp;gt;
				&amp;lt;id column=&quot;items_id&quot; property=&quot;id&quot;/&amp;gt;
				&amp;lt;result column=&quot;name&quot; property=&quot;name&quot;/&amp;gt;
				&amp;lt;result column=&quot;price&quot; property=&quot;price&quot;/&amp;gt;
				&amp;lt;result column=&quot;detail&quot; property=&quot;detail&quot;/&amp;gt;
			&amp;lt;/association&amp;gt;
		&amp;lt;/collection&amp;gt;
	&amp;lt;/collection&amp;gt;
&amp;lt;/resultMap&amp;gt;
&amp;lt;select id=&quot;queryAll&quot; resultMap=&quot;allIntoUser&quot;&amp;gt;
	SELECT
	  o.*,
	  u.username,
	  u.address,
	  d.id orderdetail_id,
	  d.items_id,
	  d.items_num,
	  i.name,
	  i.price,
	  i.detail
	FROM orders o,USER u,orderdetail d,items i
	WHERE u.id = o.user_id AND o.id = d.orders_id AND i.id = d.items_id
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;mybatis-1&quot;&gt;mybatis的延迟加载&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;!-- 查订单并延迟加载用户信息 --&amp;gt;
    &amp;lt;resultMap type=&quot;orders&quot; id=&quot;lazyLoadingUser&quot;&amp;gt;
        &amp;lt;!-- 订单信息 --&amp;gt;
        &amp;lt;id column=&quot;id&quot; property=&quot;id&quot;/&amp;gt;
        &amp;lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&amp;gt;
        &amp;lt;result column=&quot;number&quot; property=&quot;number&quot;/&amp;gt;
        &amp;lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&amp;gt;
        &amp;lt;result column=&quot;note&quot; property=&quot;note&quot;/&amp;gt;

        &amp;lt;!-- 用户信息 --&amp;gt;
        &amp;lt;!-- 
            select:延迟加载的sql语句
            column：相关表的外键
         --&amp;gt;
        &amp;lt;association property=&quot;user&quot; javaType=&quot;user&quot; select=&quot;queryUserById&quot; column=&quot;user_id&quot;&amp;gt;&amp;lt;/association&amp;gt;
    &amp;lt;/resultMap&amp;gt;
    &amp;lt;select id=&quot;queryOrdersLazyLoadingUser&quot; resultMap=&quot;lazyLoadingUser&quot;&amp;gt;
        select * from orders
    &amp;lt;/select&amp;gt;
    &amp;lt;select id=&quot;queryUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&amp;gt;
        select * from user where id = #{user_id}
    &amp;lt;/select&amp;gt;
    &amp;lt;update id=&quot;updateUserById&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot;&amp;gt;
        update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address} where id = #{id}
    &amp;lt;/update&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;mybatis-2&quot;&gt;mybatis的缓存&lt;/h3&gt;

&lt;h3 id=&quot;mybatis-3&quot;&gt;Mybatis使用第三方缓存框架&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;如果开发的程序部署在多台服务器上，假如用户访问A机器后，将用户的信息存储在该内存中，如果突然A机器的访问量突然变大，可能这时你再次访问A机器时，它会有负载均衡操作，将你切换到其他服务器上B，如果访问B的某个模块由于你在B机器没有登录过也就是没有用户的缓存信息，会提示你重新登录，这个时候你愿意接受么？这样的网站你还会访问么？&lt;/li&gt;
  &lt;li&gt;Mybatis的二级缓存指针对mapper级别，即namespace，所以只针对单表，而大多数的时候我们不仅仅是单表操作，这个时候数据到底缓存在哪个namespace下不确定，如果user和role两张表来说，如果将缓存信息保存在user下，如果角色的信息改变查询用户信息时关联角色信息，如果使用了user下的缓存这时结果查询的就是不正确的。&lt;/li&gt;
  &lt;li&gt;如果在items商品表的namespace下缓存了很多数量的商品，如果某一商品的数据发生commit操作，那么清空该namespace下的所有缓存，很明显这样是不可以接受的也是不合理的。&lt;/li&gt;
  &lt;li&gt;在互联网项目中，一般情况下我们都会使用第三方的缓存框架作为查询缓存使用。比如：redis、ehcache、memcache等。&lt;/li&gt;
  &lt;li&gt;aehcache介绍：整合ehcache，在分布式部署应用的时候，可以将ehcache做集群配置。一旦将应用部署在集群环境中，ehcache每一个节点维护各自的缓存数据，当某个节点的缓存数据进行更新后，这些更新的数据无法在其他节点中共享，这不仅会降低节点的运行效率而且还可能发生数据不同步的情况。例如某个网站采用A、B两个节点作为集群部署，当A节点的缓存更新后，而B节点缓存数据未更新，则可能出现用户在访问该网站时一会出现更新后的数据一会儿是未更新的数据。然而Ehcache1.7之后为集群提供了5中解决方案。Rmi、jms、ehcache server、jgroups、terracotta。在做集群是，ehcache中的所有缓存对象都必须得实现序列化，即实现serializable接口，这种其他集群方式下也必须得遵守。rmi下集群部署：&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mybatisspring&quot;&gt;Mybatis与Spring整合&lt;/h3&gt;
&lt;p&gt;传统dao的开发
    １．配置文件发生变化
    ２．Daoimpl　继承　sqlSessionDaoSupport
    ３．加载文件发生变化
    	String configLocation = “applicationContext.xml”;
        applicationContext = new ClassPathXmlApplicationContext(configLocation);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;代理开发dao
获取Mapper即可使用
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 17 Aug 2016 00:00:00 +0800</pubDate>
        <link>https://qoiuy.github.io/Mybatis/</link>
        <guid isPermaLink="true">https://qoiuy.github.io/Mybatis/</guid>
        
        
      </item>
    
  </channel>
</rss>
